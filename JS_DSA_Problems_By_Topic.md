
# 🧠 JavaScript DSA Problems by Topic

---

#### 🚀 **Arrays**
1. **Two Sum**  
   - Find indices of two numbers that add up to a target.

2. **Best Time to Buy and Sell Stock**  
   - Maximize profit by choosing a single buy and sell day.

3. **Maximum Subarray**  
   - Kadane’s Algorithm for largest sum subarray.

4. **Container with Most Water**  
   - Use two-pointer technique to calculate max area.

5. **Rotate Array**  
   - Rotate array elements by `k` steps.

---

#### 📝 **Strings**
1. **Reverse String**  
   - Reverse characters in place.

2. **Valid Palindrome**  
   - Check if string reads the same forward and backward.

3. **Longest Substring Without Repeating Characters**  
   - Sliding window to track unique characters.

4. **Group Anagrams**  
   - Group words with same characters in different order.

5. **Longest Palindromic Substring**  
   - Expand around center or use dynamic programming.

---

#### 🔗 **Linked List**
1. **Reverse Linked List**  
   - Iterative or recursive pointer reversal.

2. **Merge Two Sorted Lists**  
   - Combine two sorted lists into one.

3. **Remove Nth Node From End of List**  
   - Use two pointers, one delayed by `n` steps.

4. **Linked List Cycle**  
   - Detect loop using Floyd’s Cycle Detection.

5. **Intersection of Two Linked Lists**  
   - Use pointer redirection to find intersection point.

---

#### 🌳 **Trees**
1. **Maximum Depth of Binary Tree**  
   - DFS or BFS to find the deepest level.

2. **Validate Binary Search Tree**  
   - Recursively ensure left < node < right.

3. **Symmetric Tree**  
   - Mirror check of left and right subtrees.

4. **Binary Tree Level Order Traversal**  
   - BFS traversal using a queue.

5. **Lowest Common Ancestor of a Binary Tree**  
   - Traverse tree and return split path node.

---

#### 🔍 **Graphs**
1. **Number of Islands**  
   - Use DFS or BFS to count connected components.

2. **Course Schedule**  
   - Topological sort to detect cycles.

3. **Word Ladder**  
   - BFS with word transformations.

4. **Clone Graph**  
   - DFS with hashmap for visited nodes.

5. **Network Delay Time**  
   - Dijkstra's algorithm with priority queue.

---

#### 🔎 **Searching & Sorting**
1. **Merge Sort**  
   - Divide and conquer to sort arrays.

2. **Quick Sort**  
   - Partition and recursively sort halves.

3. **Binary Search**  
   - Efficient search in sorted array.

4. **Search in Rotated Sorted Array**  
   - Modified binary search.

5. **First Bad Version**  
   - Binary search on API responses.

---

#### 🎯 **Dynamic Programming**
1. **Fibonacci Number**  
   - Memoization or bottom-up approach.

2. **Climbing Stairs**  
   - Similar to Fibonacci; `dp[i] = dp[i-1] + dp[i-2]`.

3. **Longest Increasing Subsequence**  
   - `O(n^2)` DP or `O(n log n)` with binary search.

4. **Maximum Subarray Sum**  
   - Use Kadane’s Algorithm.

5. **Coin Change**  
   - Bottom-up DP to find minimum coins needed.

---
