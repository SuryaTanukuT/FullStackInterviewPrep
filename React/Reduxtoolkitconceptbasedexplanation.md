Here's how you can implement a simple **Calculator App** using **Redux Toolkit**, utilizing its powerful features like `configureStore`, `createSlice`, and `createAsyncThunk`.

---

## **Calculator App Using Redux Toolkit**

In this example, we'll build the same calculator as before but this time, using Redux Toolkit, which simplifies Redux setup and reduces boilerplate.

### 1. **Install Redux Toolkit**

First, install **Redux Toolkit** and **React-Redux**.

```bash
npm install @reduxjs/toolkit react-redux
```

### 2. **Create a Slice with `createSlice`**

We use `createSlice` to create our slice of state. It will automatically generate action creators and reducers.

Here’s how we can define a slice for our calculator:

```javascript
// src/features/calculator/calculatorSlice.js

import { createSlice } from '@reduxjs/toolkit';

// Initial state of the calculator
const initialState = {
  currentValue: 0,
  previousValue: 0,
  operation: null
};

// Create slice using createSlice
const calculatorSlice = createSlice({
  name: 'calculator',
  initialState,
  reducers: {
    addNumber: (state, action) => {
      state.currentValue = state.currentValue * 10 + action.payload;
    },
    setOperation: (state, action) => {
      state.previousValue = state.currentValue;
      state.currentValue = 0;
      state.operation = action.payload;
    },
    clearCalculator: () => initialState,
    evaluateResult: (state) => {
      let result;
      switch (state.operation) {
        case '+':
          result = state.previousValue + state.currentValue;
          break;
        case '-':
          result = state.previousValue - state.currentValue;
          break;
        case '*':
          result = state.previousValue * state.currentValue;
          break;
        case '/':
          result = state.previousValue / state.currentValue;
          break;
        default:
          result = state.currentValue;
      }
      state.currentValue = result;
      state.previousValue = 0;
      state.operation = null;
    }
  }
});

// Export actions generated by createSlice
export const { addNumber, setOperation, clearCalculator, evaluateResult } = calculatorSlice.actions;

// Export reducer to use in store
export default calculatorSlice.reducer;
```

### 3. **Configure the Store with `configureStore`**

Now, let's configure the Redux store using `configureStore`, which simplifies store creation by automatically adding middleware like Redux DevTools and thunk.

```javascript
// src/app/store.js

import { configureStore } from '@reduxjs/toolkit';
import calculatorReducer from '../features/calculator/calculatorSlice';

// Create Redux store using configureStore
const store = configureStore({
  reducer: {
    calculator: calculatorReducer
  }
});

export default store;
```

### 4. **Provide the Redux Store to the Application**

Next, we need to connect the Redux store to the React application. This is done by wrapping our app in a `<Provider>` component from `react-redux`.

```javascript
// src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import store from './app/store';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```

### 5. **Using Redux State and Dispatch in the App**

Now we can build the calculator interface, connecting it to Redux for managing the state. We'll use `useDispatch` to dispatch actions and `useSelector` to read the state from the store.

```javascript
// src/App.js

import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { addNumber, setOperation, clearCalculator, evaluateResult } from './features/calculator/calculatorSlice';

function App() {
  const dispatch = useDispatch();
  const currentValue = useSelector(state => state.calculator.currentValue);

  const handleNumberClick = (number) => {
    dispatch(addNumber(number));
  };

  const handleOperationClick = (operation) => {
    dispatch(setOperation(operation));
  };

  const handleEvaluateClick = () => {
    dispatch(evaluateResult());
  };

  const handleClearClick = () => {
    dispatch(clearCalculator());
  };

  return (
    <div className="calculator">
      <div className="display">
        {currentValue}
      </div>
      <div className="buttons">
        <button onClick={() => handleNumberClick(1)}>1</button>
        <button onClick={() => handleNumberClick(2)}>2</button>
        <button onClick={() => handleNumberClick(3)}>3</button>
        <button onClick={() => handleOperationClick('+')}>+</button>

        <button onClick={() => handleNumberClick(4)}>4</button>
        <button onClick={() => handleNumberClick(5)}>5</button>
        <button onClick={() => handleNumberClick(6)}>6</button>
        <button onClick={() => handleOperationClick('-')}>-</button>

        <button onClick={() => handleNumberClick(7)}>7</button>
        <button onClick={() => handleNumberClick(8)}>8</button>
        <button onClick={() => handleNumberClick(9)}>9</button>
        <button onClick={() => handleOperationClick('*')}>*</button>

        <button onClick={() => handleClearClick()}>C</button>
        <button onClick={() => handleNumberClick(0)}>0</button>
        <button onClick={handleEvaluateClick}>=</button>
        <button onClick={() => handleOperationClick('/')}>/</button>
      </div>
    </div>
  );
}

export default App;
```

### 6. **Optional: Using `createAsyncThunk`**

While we don't have asynchronous actions in this simple calculator, **`createAsyncThunk`** is a great tool for handling async actions, such as fetching data or performing side effects. In a real-world scenario, you might want to fetch previous calculations or handle API calls. Here’s an example of how to use `createAsyncThunk` for async operations:

```javascript
// Example of a createAsyncThunk for fetching some data (e.g., fetching operation history)
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchOperationHistory = createAsyncThunk(
  'calculator/fetchHistory',
  async (userId) => {
    const response = await fetch(`/api/history/${userId}`);
    return response.json();
  }
);
```

This can be used to add async data fetching into your app, such as fetching a history of calculations or previous operations.

### 7. **Full Redux Flow in Redux Toolkit**

The flow is much simpler with Redux Toolkit:

1. **Dispatch Actions** (via buttons):
   - When a user presses a button (like 5, +, 3, =), the corresponding action (like `addNumber`, `setOperation`, `evaluateResult`) is dispatched.
   
2. **Reducers**:
   - The reducers inside `calculatorSlice` handle the dispatched actions, update the state, and return the new state.

3. **Reactivity**:
   - The app re-renders automatically based on state changes due to the use of `useSelector` in React components.

---

## **Conclusion**

Using **Redux Toolkit** for the **Calculator App** has several advantages:
- **Reduced Boilerplate**: No need to write separate action types and action creators manually.
- **Simplified Configuration**: `configureStore` automatically sets up middleware and integrates with Redux DevTools.
- **Built-in Async Handling**: With `createAsyncThunk`, we can easily handle asynchronous logic, though it's not used in this simple calculator.
- **Code Organization**: With `createSlice`, actions and reducers are colocated in a way that is easy to manage and maintain.

This approach not only streamlines the process but also allows the app to scale easily as more features are added.